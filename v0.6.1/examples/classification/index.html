<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Classification of penguin species · CalibrationErrors.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://devmotion.github.io/CalibrationErrors.jl/examples/classification/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CalibrationErrors.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CalibrationErrors.jl</a></li><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><a class="tocitem" href="../../ece/">Expected calibration error (ECE)</a></li><li><a class="tocitem" href="../../kce/">Kernel calibration error (KCE)</a></li><li><a class="tocitem" href="../../others/">Other calibration errors</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Classification of penguin species</a><ul class="internal"><li><a class="tocitem" href="#Packages"><span>Packages</span></a></li><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#Fitting-normal-distributions"><span>Fitting normal distributions</span></a></li><li><a class="tocitem" href="#Naive-Bayes-classifier"><span>Naive Bayes classifier</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li></ul></li><li><a class="tocitem" href="../distribution/">Distribution of calibration error estimates</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Classification of penguin species</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Classification of penguin species</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/devmotion/CalibrationErrors.jl/blob/main/examples/classification/script.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Classification-of-penguin-species"><a class="docs-heading-anchor" href="#Classification-of-penguin-species">Classification of penguin species</a><a id="Classification-of-penguin-species-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-penguin-species" title="Permalink"></a></h1><p><a href="https://nbviewer.jupyter.org/github/devmotion/CalibrationErrors.jl/blob/gh-pages/v0.6.1/examples/classification/notebook.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p><em>You are seeing the HTML output generated by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a> from the <a href="https://github.com/devmotion/CalibrationErrors.jl/blob/main/examples/classification/script.jl">Julia source file</a>. The corresponding notebook can be viewed in <a href="https://nbviewer.jupyter.org/github/devmotion/CalibrationErrors.jl/blob/gh-pages/v0.6.1/examples/classification/notebook.ipynb">nbviewer</a>.</em></p><h2 id="Packages"><a class="docs-heading-anchor" href="#Packages">Packages</a><a id="Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using AlgebraOfGraphics
using CairoMakie
using CalibrationErrors
using DataFrames
using Distributions
using MLJ
using MLJNaiveBayesInterface
using PalmerPenguins

using Random

# Plotting settings
set_aog_theme!()
CairoMakie.activate!(; type=&quot;svg&quot;)</code></pre><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><p>In this example we study the calibration of different models that classify three penguin species based on measurements of their bill and flipper lengths.</p><p>We use the <a href="https://allisonhorst.github.io/palmerpenguins/">Palmer penguins dataset</a> to to train and validate the models.</p><pre><code class="language-julia hljs">penguins = dropmissing(DataFrame(PalmerPenguins.load()))

penguins_mapping =
    data(penguins) * mapping(
        :bill_length_mm =&gt; &quot;bill length (mm)&quot;, :flipper_length_mm =&gt; &quot;flipper length (mm)&quot;
    )
draw(penguins_mapping * mapping(; color=:species) * visual(; alpha=0.7))</code></pre><p><img src="3445056049.svg" alt/></p><p>We split the data randomly into a training and validation dataset. The training dataset contains around 60% of the samples.</p><pre><code class="language-julia hljs">Random.seed!(1234)
n = nrow(penguins)
k = floor(Int, 0.7 * n)
Random.seed!(100)
penguins.train = shuffle!(vcat(trues(k), falses(n - k)))

# Plot the training and validation data
dataset = :train =&gt; renamer(true =&gt; &quot;training&quot;, false =&gt; &quot;validation&quot;) =&gt; &quot;Dataset&quot;
plt = penguins_mapping * mapping(; color=:species, col=dataset) * visual(; alpha=0.7)
draw(plt; axis=(height=300,))</code></pre><p><img src="275588915.svg" alt/></p><h2 id="Fitting-normal-distributions"><a class="docs-heading-anchor" href="#Fitting-normal-distributions">Fitting normal distributions</a><a id="Fitting-normal-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-normal-distributions" title="Permalink"></a></h2><p>For each species, we fit independent normal distributions to the observations of the bill and flipper length in the training data, using maximum likelihood estimation.</p><pre><code class="language-julia hljs">y, X = unpack(
    penguins,
    ==(:species),
    x -&gt; x === :bill_length_mm || x === :flipper_length_mm;
    :species =&gt; Multiclass,
    :bill_length_mm =&gt; MLJ.Continuous,
    :flipper_length_mm =&gt; MLJ.Continuous,
)
model = fit!(machine(GaussianNBClassifier(), X, y); rows=penguins.train);
nothing #hide</code></pre><pre><code class="nohighlight hljs">[ Info: Training Machine{GaussianNBClassifier,…}.
</code></pre><p>We plot the estimated normal distributions.</p><pre><code class="language-julia hljs"># plot datasets
fg = draw(plt; axis=(height=300,))

# plot Gaussian distributions
xgrid = range(extrema(penguins.bill_length_mm)...; length=100)
ygrid = range(extrema(penguins.flipper_length_mm)...; length=100)
let f = (x, y, dist) -&gt; pdf(dist, [x, y])
    for (class, color) in zip(classes(y), Makie.wong_colors())
        pdfs = f.(xgrid, ygrid&#39;, Ref(model.fitresult.gaussians[class]))
        contour!(fg.figure[1, 1], xgrid, ygrid, pdfs; color=color)
        contour!(fg.figure[1, 2], xgrid, ygrid, pdfs; color=color)
    end
end

fg</code></pre><p><img src="2705135972.svg" alt/></p><h2 id="Naive-Bayes-classifier"><a class="docs-heading-anchor" href="#Naive-Bayes-classifier">Naive Bayes classifier</a><a id="Naive-Bayes-classifier-1"></a><a class="docs-heading-anchor-permalink" href="#Naive-Bayes-classifier" title="Permalink"></a></h2><p>Let us assume that the bill and flipper length are conditionally independent given the penguin species. Then Bayes&#39; theorem implies that</p><p class="math-container">\[\begin{aligned}
\mathbb{P}(\mathrm{species} \,|\, \mathrm{bill}, \mathrm{flipper})
&amp;= \frac{\mathbb{P}(\mathrm{species}) \mathbb{P}(\mathrm{bill}, \mathrm{flipper} \,|\, \mathrm{species})}{\mathbb{P}(\mathrm{bill}, \mathrm{flipper})} \\
&amp;= \frac{\mathbb{P}(\mathrm{species}) \mathbb{P}(\mathrm{bill} \,|\, \mathrm{species}) \mathbb{P}(\mathrm{flipper} \,|\, \mathrm{species})}{\mathbb{P}(\mathrm{bill}, \mathrm{flipper})}.
\end{aligned}\]</p><p>This predictive model is known as <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">naive Bayes classifier</a>.</p><p>In the section above, we estimated <span>$\mathbb{P}(\mathrm{species})$</span>, <span>$\mathbb{P}(\mathrm{bill} \,|\, \mathrm{species})$</span>, and <span>$\mathbb{P}(\mathrm{flipper} \,|\, \mathrm{species})$</span> for each penguin species from the training data. For the conditional distributions we used a Gaussian approximation.</p><pre><code class="language-julia hljs">predictions = MLJ.predict(model)
train_predict = predictions[penguins.train]
val_predict = predictions[.!penguins.train]

# Plot datasets
fg = draw(plt; axis=(height=300,))

# Plot predictions
predictions_grid = reshape(
    MLJ.predict(model, reduce(hcat, vcat.(xgrid, ygrid&#39;))&#39;), length(xgrid), length(ygrid)
)
for (class, color) in zip(classes(y), Makie.wong_colors())
    p = pdf.(predictions_grid, class)
    contour!(fg.figure[1, 1], xgrid, ygrid, p; color=color)
    contour!(fg.figure[1, 2], xgrid, ygrid, p; color=color)
end

fg</code></pre><p><img src="291991058.svg" alt/></p><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>We evaluate the probabilistic predictions of the naive Bayes classifier that we just trained.</p><h3 id="Log-likelihood"><a class="docs-heading-anchor" href="#Log-likelihood">Log-likelihood</a><a id="Log-likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Log-likelihood" title="Permalink"></a></h3><p>We compute the average log-likelihood of the validation data. It is equivalent to the negative cross-entropy.</p><pre><code class="language-julia hljs">val_y = y[.!penguins.train]
-mean(cross_entropy(val_predict, val_y))</code></pre><pre><code class="nohighlight hljs">-0.12188703745583586</code></pre><h3 id="Brier-score"><a class="docs-heading-anchor" href="#Brier-score">Brier score</a><a id="Brier-score-1"></a><a class="docs-heading-anchor-permalink" href="#Brier-score" title="Permalink"></a></h3><p>The average log-likelihood is also equivalent to the <a href="https://sites.stat.washington.edu/raftery/Research/PDF/Gneiting2007jasa.pdf">logarithmic score</a>. The Brier score is another strictly proper scoring rule that can be used for evaluating probabilistic predictions.</p><pre><code class="language-julia hljs">mean(brier_score(val_predict, val_y))</code></pre><pre><code class="nohighlight hljs">-0.07385286949971775</code></pre><h3 id="Expected-calibration-error"><a class="docs-heading-anchor" href="#Expected-calibration-error">Expected calibration error</a><a id="Expected-calibration-error-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-calibration-error" title="Permalink"></a></h3><p>As all proper scoring rules, the logarithmic and the Brier score can be <a href="https://doi.org/10.1002/qj.456">decomposed in three terms that quantify the sharpness and calibration of the predictive model and the irreducible uncertainty of the targets that is inherent to the prediction problem</a>. The calibration term in this decomposition is the expected calibration error (ECE)</p><p class="math-container">\[\mathbb{E} d\big(P_X, \mathrm{law}(Y \,|\, P_X)\big)\]</p><p>with respect to the score divergence <span>$d$</span>.</p><p>Scoring rules, however, include also the sharpness and the uncertainty term. Thus models can trade off calibration for sharpness and therefore scoring rules are not suitable for specifically evaluating calibration of predictive models.</p><p>The score divergence to the logarithmic and the Brier score are the Kullback-Leibler (KL) divergence</p><p class="math-container">\[d\big(P_X, \mathrm{law}(Y \,|\, P_X)\big) = \sum_{y} \mathbb{P}(Y = y \,|\, P_X)
\log\big(\mathbb{P}(Y = y \,|\, P_X) / P_X(\{y\})\big)\]</p><p>and the squared Euclidean distance</p><p class="math-container">\[d\big(P_X, \mathrm{law}(Y \,|\, P_X)\big) = \sum_{y} \big(P_X - \mathrm{law}(Y \,|\, P_X)\big)^2(\{y\}),\]</p><p>respectively. The KL divergence is defined only if <span>$\mathrm{law}(Y \,|\, P_X)$</span> is absolutely continuous with respect to <span>$P_X$</span>, i.e., if <span>$P_X(\{y\}) = 0$</span> implies <span>$\mathbb{P}(Y = y \,|\, P_X) = 0$</span>.</p><p>We estimate the ECE by binning the probability simplex of predictions <span>$P_X$</span> and computing the weighted average of the distances between the mean prediction and the distribution of targets in each bin.</p><p>One approach is to use bins of uniform size.</p><pre><code class="language-julia hljs">ece = ECE(UniformBinning(10), (μ, y) -&gt; kl_divergence(y, μ));
nothing #hide</code></pre><p>We have to work with a numerical encoding of the true penguin species and a corresponding vector of predictions. We use <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/stable/api/#KernelFunctions.RowVecs"><code>RowVecs</code></a> to indicate that the rows in the matrix of probabilities returned by <code>pdf</code> are the predictions. If we would provide predictions as columns of a matrix, we would have to use <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/stable/api/#KernelFunctions.ColVecs"><code>ColVecs</code></a>.</p><pre><code class="language-julia hljs">val_yint = map(MLJ.levelcode, val_y)
val_probs = RowVecs(pdf(val_predict, MLJ.classes(y)));
nothing #hide</code></pre><p>We compute the estimate on the validation data:</p><pre><code class="language-julia hljs">ece(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.04860861700674836</code></pre><p>For the squared Euclidean distance we obtain:</p><pre><code class="language-julia hljs">ece = ECE(UniformBinning(10), SqEuclidean())
ece(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.02426469201343113</code></pre><p>Alternatively, one can use a data-dependent binning scheme that tries to split the predictions in a way that minimizes the variance in each bin.</p><p>With the KL divergence we get:</p><pre><code class="language-julia hljs">ece = ECE(MedianVarianceBinning(5), (μ, y) -&gt; kl_divergence(y, μ))
ece(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.027874966150111966</code></pre><p>For the squared Euclidean distance we obtain:</p><pre><code class="language-julia hljs">ece = ECE(MedianVarianceBinning(5), SqEuclidean())
ece(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.012238423729555838</code></pre><p>We see that the estimates (of the same theoretical quantity!) are highly dependent on the chosen binning scheme.</p><h3 id="Kernel-calibration-error"><a class="docs-heading-anchor" href="#Kernel-calibration-error">Kernel calibration error</a><a id="Kernel-calibration-error-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-calibration-error" title="Permalink"></a></h3><p>As an alternative to the ECE, we estimate the kernel calibration error (KCE). We keep it simple here, and use the tensor product kernel</p><p class="math-container">\[k\big((\mu, y), (\mu&#39;, y&#39;)\big) = \delta_{y,y&#39;} \exp{\bigg(-\frac{{\|\mu - \mu&#39;\|}_2^2}{2\nu^2} \bigg)}\]</p><p>with length scale <span>$\nu &gt; 0$</span> for predictions <span>$\mu,\mu&#39;$</span> and corresponding targets <span>$y, y&#39;$</span>. For simplicity, we estimate length scale <span>$\nu$</span> with the median heuristic.</p><pre><code class="language-julia hljs">distances = pairwise(SqEuclidean(), RowVecs(pdf(train_predict, MLJ.classes(y))))
ν = sqrt(median(distances[i] for i in CartesianIndices(distances) if i[1] &lt; i[2]))
kernel = with_lengthscale(GaussianKernel(), ν) ⊗ WhiteKernel();
nothing #hide</code></pre><p>We obtain the following biased estimate of the squared KCE (SKCE):</p><pre><code class="language-julia hljs">skce = SKCE(kernel; unbiased=false)
skce(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.0007888007181424232</code></pre><p>Similar to the biased estimates of the ECE, the biased estimates of the SKCE are always non-negative. The unbiased estimates can be negative as well, in particular if the model is (close to being) calibrated:</p><pre><code class="language-julia hljs">skce = SKCE(kernel)
skce(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">5.077982135882213e-5</code></pre><p>When the datasets are large, the quadratic sample complexity of the standard biased and unbiased estimators of the SKCE can become prohibitive. In these cases, one can resort to an estimator that averages estimates of non-overlapping blocks of samples. This estimator allows to trade off computational cost for increased variance.</p><p>Here we consider the extreme case of blocks with two samples, which yields an estimator with linear sample complexity:</p><pre><code class="language-julia hljs">skce = SKCE(kernel; blocksize=2)
skce(val_probs, val_yint)</code></pre><pre><code class="nohighlight hljs">0.019033063524410525</code></pre><h3 id="Package-and-system-information"><a class="docs-heading-anchor" href="#Package-and-system-information">Package and system information</a><a id="Package-and-system-information-1"></a><a class="docs-heading-anchor-permalink" href="#Package-and-system-information" title="Permalink"></a></h3><h4 id="Package-version"><a class="docs-heading-anchor" href="#Package-version">Package version</a><a id="Package-version-1"></a><a class="docs-heading-anchor-permalink" href="#Package-version" title="Permalink"></a></h4><pre><code class="language-julia hljs">      Status `~/work/CalibrationErrors.jl/CalibrationErrors.jl/examples/classification/Project.toml`
  [cbdf2221] AlgebraOfGraphics v0.6.4
  [13f3f980] CairoMakie v0.7.2
  [33913031] CalibrationErrors v0.6.1
  [a93c6f00] DataFrames v1.3.2
  [31c24e10] Distributions v0.25.48
  [add582a8] MLJ v0.17.1
  [33e4bacb] MLJNaiveBayesInterface v0.1.5
  [8b842266] PalmerPenguins v0.1.3</code></pre><h4 id="Computer-information"><a class="docs-heading-anchor" href="#Computer-information">Computer information</a><a id="Computer-information-1"></a><a class="docs-heading-anchor-permalink" href="#Computer-information" title="Permalink"></a></h4><pre><code class="nohighlight hljs">Julia Version 1.7.2
Commit bf53498635 (2022-02-06 15:21 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-12.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_DEBUG = Documenter</code></pre><h4 id="Manifest"><a class="docs-heading-anchor" href="#Manifest">Manifest</a><a id="Manifest-1"></a><a class="docs-heading-anchor-permalink" href="#Manifest" title="Permalink"></a></h4><p>To reproduce the project environment of this example you can <a href="Manifest.toml">download the full Manifest.toml</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../others/">« Other calibration errors</a><a class="docs-footer-nextpage" href="../distribution/">Distribution of calibration error estimates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 15 February 2022 01:49">Tuesday 15 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
